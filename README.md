# é‡åŒ–æ•°æ®å¹³å° (Quantitative Data Platform)

ä¸€ä¸ªä¸“ä¸šçš„è‚¡ç¥¨æ•°æ®è·å–ã€å­˜å‚¨ã€åˆ†æå¹³å°ï¼Œä¸ºé‡åŒ–æŠ•èµ„æä¾›å®Œæ•´çš„æ•°æ®è§£å†³æ–¹æ¡ˆã€‚

## ğŸ“‹ ç›®å½•

- [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
- [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
- [æŠ€æœ¯æ–¹æ¡ˆ](#æŠ€æœ¯æ–¹æ¡ˆ)
- [æ ¸å¿ƒæ¨¡å—](#æ ¸å¿ƒæ¨¡å—)
- [å®‰è£…é…ç½®](#å®‰è£…é…ç½®)
- [ä½¿ç”¨æŒ‡å—](#ä½¿ç”¨æŒ‡å—)
- [æ•°æ®æ¨¡å‹](#æ•°æ®æ¨¡å‹)
- [APIæ¥å£](#apiæ¥å£)
- [æµ‹è¯•ä½“ç³»](#æµ‹è¯•ä½“ç³»)
- [æ•°æ®äº§å‡º](#æ•°æ®äº§å‡º)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [æ‰©å±•å¼€å‘](#æ‰©å±•å¼€å‘)
- [éƒ¨ç½²è¿ç»´](#éƒ¨ç½²è¿ç»´)

## ğŸ¯ é¡¹ç›®æ¦‚è¿°

### è®¾è®¡ç›®æ ‡

æœ¬å¹³å°æ—¨åœ¨æ„å»ºä¸€ä¸ªé«˜æ€§èƒ½ã€å¯æ‰©å±•ã€æ˜“ç»´æŠ¤çš„é‡åŒ–æ•°æ®å¹³å°ï¼Œè§£å†³ä»¥ä¸‹æ ¸å¿ƒé—®é¢˜ï¼š

1. **æ•°æ®è·å–**: ç»Ÿä¸€å¤šæ•°æ®æºæ¥å£ï¼Œæ”¯æŒå®æ—¶å’Œå†å²æ•°æ®è·å–
2. **æ•°æ®å­˜å‚¨**: é«˜æ•ˆçš„åˆ—å¼å­˜å‚¨ï¼Œæ”¯æŒå¤§è§„æ¨¡æ•°æ®å¿«é€ŸæŸ¥è¯¢
3. **æ•°æ®å¤„ç†**: æ ‡å‡†åŒ–çš„æ•°æ®æ¸…æ´—ã€è½¬æ¢å’Œè´¨é‡æ§åˆ¶
4. **æ•°æ®åˆ†æ**: ä¸“ä¸šçš„è´¢åŠ¡åˆ†æã€æŠ€æœ¯åˆ†æå’Œé‡åŒ–æŒ‡æ ‡è®¡ç®—
5. **ç³»ç»Ÿé›†æˆ**: ç®€æ´çš„APIè®¾è®¡ï¼Œä¾¿äºé›†æˆåˆ°é‡åŒ–ç­–ç•¥ç³»ç»Ÿ

### æ ¸å¿ƒç‰¹æ€§

- âœ… **å¤šæ•°æ®æºæ”¯æŒ**: èšå®½ã€Windã€åŒèŠ±é¡ºç­‰ä¸»æµæ•°æ®æº
- âœ… **é«˜æ€§èƒ½å­˜å‚¨**: DuckDBåˆ—å¼å­˜å‚¨ï¼ŒæŸ¥è¯¢é€Ÿåº¦æå‡10å€ä»¥ä¸Š
- âœ… **å®Œæ•´æ•°æ®æ¨¡å‹**: è¦†ç›–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯ã€è´¢åŠ¡æ•°æ®ã€å¸‚åœºæ•°æ®ã€æŠ€æœ¯æŒ‡æ ‡
- âœ… **æ™ºèƒ½æ›´æ–°æœºåˆ¶**: å¢é‡æ›´æ–°ã€å®šæœŸæ›´æ–°ã€æ•°æ®ä¿®å¤å’Œè´¨é‡æ£€æŸ¥
- âœ… **ä¸“ä¸šåˆ†æå·¥å…·**: è´¢åŠ¡å¥åº·ã€ç›ˆåˆ©èƒ½åŠ›ã€æˆé•¿æ€§ã€ä¼°å€¼ã€æŠ€æœ¯åˆ†æ
- âœ… **ç®€æ´APIè®¾è®¡**: ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒå¿«é€ŸæŸ¥è¯¢å’Œæ‰¹é‡æ“ä½œ
- âœ… **å®Œå–„æµ‹è¯•ä½“ç³»**: å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•
- âœ… **å¯æ‰©å±•æ¶æ„**: æ’ä»¶åŒ–è®¾è®¡ï¼Œæ”¯æŒè‡ªå®šä¹‰æ•°æ®æºå’Œåˆ†ææ¨¡å—

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application Layer)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‘½ä»¤è¡Œå·¥å…·  â”‚  APIæ¥å£  â”‚  åˆ†æå·¥å…·  â”‚  æ•°æ®ç®¡ç†  â”‚  æµ‹è¯•å·¥å…·  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æœåŠ¡å±‚ (Service Layer)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ•°æ®æœåŠ¡ â”‚ æ›´æ–°æœåŠ¡ â”‚ åˆ†ææœåŠ¡ â”‚ è‚¡ç¥¨åˆ—è¡¨æœåŠ¡ â”‚ è´¨é‡æ£€æŸ¥æœåŠ¡ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ä¸šåŠ¡å±‚ (Business Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    APIç®¡ç†å™¨    â”‚   æ•°æ®æºç®¡ç†å™¨   â”‚   æ•°æ®åº“ç®¡ç†å™¨   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®å±‚ (Data Layer)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ•°æ®æ¨¡å‹  â”‚  æ•°æ®æä¾›å•†  â”‚  æ•°æ®åº“å®ç°  â”‚  é…ç½®ç®¡ç†  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   åŸºç¡€è®¾æ–½å±‚ (Infrastructure)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚    DuckDB    â”‚    èšå®½API    â”‚    ç½‘ç»œé€šä¿¡    â”‚    æ—¥å¿—ç³»ç»Ÿ    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¾è®¡åŸåˆ™

1. **åˆ†å±‚æ¶æ„**: æ¸…æ™°çš„åˆ†å±‚è®¾è®¡ï¼ŒèŒè´£åˆ†ç¦»ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **æ¥å£æŠ½è±¡**: å®šä¹‰æ ‡å‡†æ¥å£ï¼Œæ”¯æŒå¤šç§å®ç°ï¼Œæé«˜ç³»ç»Ÿçµæ´»æ€§
3. **ä¾èµ–æ³¨å…¥**: é€šè¿‡é…ç½®ç®¡ç†ä¾èµ–å…³ç³»ï¼Œé™ä½æ¨¡å—è€¦åˆåº¦
4. **æ’ä»¶åŒ–è®¾è®¡**: æ”¯æŒåŠ¨æ€åŠ è½½æ•°æ®æºå’Œåˆ†ææ¨¡å—
5. **é”™è¯¯å¤„ç†**: å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé”™è¯¯æ¢å¤æœºåˆ¶
6. **æ€§èƒ½ä¼˜åŒ–**: ç¼“å­˜æœºåˆ¶ã€æ‰¹é‡æ“ä½œã€å¼‚æ­¥å¤„ç†

## ğŸ”§ æŠ€æœ¯æ–¹æ¡ˆ

### æ ¸å¿ƒæŠ€æœ¯æ ˆ

| æŠ€æœ¯é¢†åŸŸ | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬è¦æ±‚ | é€‰æ‹©ç†ç”± |
|---------|---------|---------|----------|
| **ç¼–ç¨‹è¯­è¨€** | Python | 3.8+ | ä¸°å¯Œçš„æ•°æ®ç§‘å­¦ç”Ÿæ€ï¼Œæ˜“äºå¼€å‘å’Œç»´æŠ¤ |
| **æ•°æ®åº“** | DuckDB | 0.8+ | é«˜æ€§èƒ½åˆ—å¼å­˜å‚¨ï¼Œæ”¯æŒå¤æ‚åˆ†ææŸ¥è¯¢ |
| **æ•°æ®å¤„ç†** | Pandas | 1.3+ | å¼ºå¤§çš„æ•°æ®å¤„ç†å’Œåˆ†æèƒ½åŠ› |
| **æ•°å€¼è®¡ç®—** | NumPy | 1.20+ | é«˜æ•ˆçš„æ•°å€¼è®¡ç®—å’Œæ•°ç»„æ“ä½œ |
| **é…ç½®ç®¡ç†** | PyYAML | 6.0+ | çµæ´»çš„é…ç½®æ–‡ä»¶æ ¼å¼ |
| **æ—¥å¿—ç³»ç»Ÿ** | Python logging | å†…ç½® | æ ‡å‡†åŒ–çš„æ—¥å¿—è®°å½•å’Œç®¡ç† |
| **æµ‹è¯•æ¡†æ¶** | pytest | 6.0+ | åŠŸèƒ½å¼ºå¤§çš„æµ‹è¯•æ¡†æ¶ |
| **ä»£ç è´¨é‡** | black, flake8 | æœ€æ–° | ä»£ç æ ¼å¼åŒ–å’Œè´¨é‡æ£€æŸ¥ |

### æ•°æ®å­˜å‚¨æ–¹æ¡ˆ

#### DuckDBé€‰æ‹©ç†ç”±

1. **é«˜æ€§èƒ½**: åˆ—å¼å­˜å‚¨ï¼ŒæŸ¥è¯¢é€Ÿåº¦æ¯”ä¼ ç»Ÿæ•°æ®åº“å¿«10-100å€
2. **è½»é‡çº§**: åµŒå…¥å¼æ•°æ®åº“ï¼Œæ— éœ€ç‹¬ç«‹æœåŠ¡å™¨
3. **SQLå…¼å®¹**: æ”¯æŒæ ‡å‡†SQLï¼Œå­¦ä¹ æˆæœ¬ä½
4. **åˆ†æå‹å¥½**: ä¸“ä¸ºOLAPåœºæ™¯è®¾è®¡ï¼Œæ”¯æŒå¤æ‚åˆ†ææŸ¥è¯¢
5. **Pythoné›†æˆ**: åŸç”ŸPythonæ”¯æŒï¼ŒAPIç®€æ´æ˜“ç”¨

#### æ•°æ®åˆ†åŒºç­–ç•¥

```sql
-- æŒ‰å¹´ä»½åˆ†åŒºå­˜å‚¨å†å²æ•°æ®
CREATE TABLE stock_price_2023 AS SELECT * FROM stock_price WHERE year = 2023;
CREATE TABLE stock_price_2024 AS SELECT * FROM stock_price WHERE year = 2024;

-- æŒ‰è‚¡ç¥¨ä»£ç åˆ†åŒºå­˜å‚¨
CREATE TABLE stock_data_main AS SELECT * FROM stock_data WHERE code LIKE '6%';
CREATE TABLE stock_data_gem AS SELECT * FROM stock_data WHERE code LIKE '3%';
```

### æ•°æ®æºé›†æˆæ–¹æ¡ˆ

#### æŠ½è±¡æ¥å£è®¾è®¡

```python
class BaseDataSource(ABC):
    """æ•°æ®æºåŸºç±»"""
    
    @abstractmethod
    def authenticate(self) -> bool:
        """è®¤è¯"""
        pass
    
    @abstractmethod
    def get_stock_list(self) -> pd.DataFrame:
        """è·å–è‚¡ç¥¨åˆ—è¡¨"""
        pass
    
    @abstractmethod
    def get_price_data(self, code: str, start_date: date, end_date: date) -> pd.DataFrame:
        """è·å–ä»·æ ¼æ•°æ®"""
        pass
```

#### å¤šæ•°æ®æºç®¡ç†

```python
class DataSourceManager:
    """æ•°æ®æºç®¡ç†å™¨"""
    
    def __init__(self):
        self.sources = {}
        self.primary_source = None
        self.fallback_sources = []
    
    def add_source(self, name: str, source: BaseDataSource):
        """æ·»åŠ æ•°æ®æº"""
        self.sources[name] = source
    
    def get_data_with_fallback(self, method: str, *args, **kwargs):
        """å¸¦æ•…éšœè½¬ç§»çš„æ•°æ®è·å–"""
        for source in [self.primary_source] + self.fallback_sources:
            try:
                return getattr(source, method)(*args, **kwargs)
            except Exception as e:
                logger.warning(f"æ•°æ®æº {source} å¤±è´¥: {e}")
                continue
        raise Exception("æ‰€æœ‰æ•°æ®æºéƒ½ä¸å¯ç”¨")
```

## ğŸ“¦ æ ¸å¿ƒæ¨¡å—

### 1. æ•°æ®æ¨¡å‹å±‚ (`models/`)

#### åŸºç¡€æ¨¡å‹ (`base.py`)

```python
class BaseModel:
    """æ•°æ®æ¨¡å‹åŸºç±»"""
    
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    @classmethod
    def from_dict(cls, data: dict):
        """ä»å­—å…¸åˆ›å»ºå¯¹è±¡"""
        return cls(**data)
    
    def to_dict(self) -> dict:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {k: v for k, v in self.__dict__.items() if not k.startswith('_')}
    
    def validate(self) -> bool:
        """æ•°æ®éªŒè¯"""
        return True
    
    @classmethod
    def get_table_name(cls) -> str:
        """è·å–æ•°æ®åº“è¡¨å"""
        return cls.__name__.lower()
```

#### è‚¡ç¥¨ä¿¡æ¯æ¨¡å‹ (`stock_list.py`)

```python
class StockInfo(BaseModel):
    """è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯æ¨¡å‹"""
    
    def __init__(self, code: str, display_name: str, name: str, 
                 start_date: date, end_date: date = None, 
                 exchange: str = None, market: str = None, 
                 industry_name: str = None, status: str = 'normal', **kwargs):
        super().__init__(**kwargs)
        self.code = code
        self.display_name = display_name
        self.name = name
        self.start_date = start_date
        self.end_date = end_date
        self.exchange = exchange
        self.market = market
        self.industry_name = industry_name
        self.status = status
    
    @property
    def is_active(self) -> bool:
        """æ˜¯å¦ä¸ºæ´»è·ƒè‚¡ç¥¨"""
        return self.end_date is None and self.status == 'normal'
    
    def to_jq_code(self) -> str:
        """è½¬æ¢ä¸ºèšå®½ä»£ç æ ¼å¼"""
        if '.XSHE' in self.code or '.XSHG' in self.code:
            return self.code
        
        if self.code.endswith('.SZ'):
            return self.code.replace('.SZ', '.XSHE')
        elif self.code.endswith('.SH'):
            return self.code.replace('.SH', '.XSHG')
        elif self.code.endswith('.BJ'):
            return self.code.replace('.BJ', '.BSE')
        
        return self.code
```

#### è´¢åŠ¡æ•°æ®æ¨¡å‹ (`financial.py`)

```python
class IncomeStatement(BaseModel):
    """åˆ©æ¶¦è¡¨æ¨¡å‹"""
    
    def __init__(self, code: str, pub_date: date, stat_date: date,
                 total_operating_revenue: float = None,
                 operating_profit: float = None,
                 net_profit: float = None, **kwargs):
        super().__init__(**kwargs)
        self.code = code
        self.pub_date = pub_date
        self.stat_date = stat_date
        self.total_operating_revenue = total_operating_revenue
        self.operating_profit = operating_profit
        self.net_profit = net_profit
    
    @property
    def profit_margin(self) -> float:
        """å‡€åˆ©æ¶¦ç‡"""
        if self.total_operating_revenue and self.net_profit:
            return self.net_profit / self.total_operating_revenue
        return 0.0
    
    @property
    def operating_margin(self) -> float:
        """è¥ä¸šåˆ©æ¶¦ç‡"""
        if self.total_operating_revenue and self.operating_profit:
            return self.operating_profit / self.total_operating_revenue
        return 0.0
```

### 2. æ•°æ®æä¾›å•†å±‚ (`providers/`)

#### èšå®½æ•°æ®æº (`jqdata.py`)

```python
class JQDataSource(BaseDataSource):
    """èšå®½æ•°æ®æºå®ç°"""
    
    def __init__(self, config: DataSourceConfig):
        self.config = config
        self.authenticated = False
    
    def authenticate(self) -> bool:
        """èšå®½è®¤è¯"""
        try:
            import jqdata
            jqdata.auth(self.config.username, self.config.password)
            self.authenticated = True
            return True
        except Exception as e:
            logger.error(f"èšå®½è®¤è¯å¤±è´¥: {e}")
            return False
    
    def get_stock_list(self) -> pd.DataFrame:
        """è·å–è‚¡ç¥¨åˆ—è¡¨"""
        if not self.authenticated:
            raise Exception("æœªè®¤è¯")
        
        import jqdata
        stocks = jqdata.get_all_securities('stock')
        
        # è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
        result = []
        for code, info in stocks.iterrows():
            stock_info = StockInfo(
                code=self._to_standard_code(code),
                display_name=info['display_name'],
                name=info['name'],
                start_date=info['start_date'],
                end_date=info['end_date'] if pd.notna(info['end_date']) else None
            )
            result.append(stock_info.to_dict())
        
        return pd.DataFrame(result)
    
    def _to_standard_code(self, jq_code: str) -> str:
        """èšå®½ä»£ç è½¬æ ‡å‡†ä»£ç """
        if '.XSHE' in jq_code:
            return jq_code.replace('.XSHE', '.SZ')
        elif '.XSHG' in jq_code:
            return jq_code.replace('.XSHG', '.SH')
        elif '.BSE' in jq_code:
            return jq_code.replace('.BSE', '.BJ')
        return jq_code
```

### 3. æœåŠ¡å±‚ (`services/`)

#### æ•°æ®æœåŠ¡ (`data_service.py`)

```python
class DataService:
    """æ•°æ®æœåŠ¡"""
    
    def __init__(self, db_manager: DatabaseManager, data_source_manager: DataSourceManager):
        self.db_manager = db_manager
        self.data_source_manager = data_source_manager
    
    def get_stock_data(self, code: str, data_type: str, 
                      start_date: date = None, end_date: date = None) -> pd.DataFrame:
        """è·å–è‚¡ç¥¨æ•°æ®"""
        # å…ˆä»æ•°æ®åº“æŸ¥è¯¢
        local_data = self._query_local_data(code, data_type, start_date, end_date)
        
        # æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
        if self._is_data_complete(local_data, start_date, end_date):
            return local_data
        
        # ä»æ•°æ®æºè·å–ç¼ºå¤±æ•°æ®
        missing_data = self._fetch_missing_data(code, data_type, start_date, end_date)
        
        # åˆå¹¶å¹¶ä¿å­˜æ•°æ®
        if not missing_data.empty:
            self._save_data(missing_data, data_type)
            return pd.concat([local_data, missing_data]).drop_duplicates()
        
        return local_data
    
    def _query_local_data(self, code: str, data_type: str, 
                         start_date: date, end_date: date) -> pd.DataFrame:
        """æŸ¥è¯¢æœ¬åœ°æ•°æ®"""
        table_name = self._get_table_name(data_type)
        
        sql = f"SELECT * FROM {table_name} WHERE code = ?"
        params = [code]
        
        if start_date:
            sql += " AND date >= ?"
            params.append(start_date)
        
        if end_date:
            sql += " AND date <= ?"
            params.append(end_date)
        
        sql += " ORDER BY date"
        
        return self.db_manager.query(sql, params)
```

#### åˆ†ææœåŠ¡ (`analysis_service.py`)

```python
class AnalysisService:
    """åˆ†ææœåŠ¡"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    def comprehensive_analysis(self, code: str) -> AnalysisResult:
        """ç»¼åˆåˆ†æ"""
        # è·å–å„ç»´åº¦åˆ†æç»“æœ
        financial_health = self.analyze_financial_health(code)
        profitability = self.analyze_profitability(code)
        growth = self.analyze_growth(code)
        valuation = self.analyze_valuation(code)
        technical = self.analyze_technical_indicators(code)
        
        # è®¡ç®—ç»¼åˆè¯„åˆ†
        weights = {
            'financial_health': 0.25,
            'profitability': 0.25,
            'growth': 0.20,
            'valuation': 0.15,
            'technical': 0.15
        }
        
        total_score = (
            financial_health.score * weights['financial_health'] +
            profitability.score * weights['profitability'] +
            growth.score * weights['growth'] +
            valuation.score * weights['valuation'] +
            technical.score * weights['technical']
        )
        
        # ç¡®å®šè¯„çº§
        rating = self._get_rating(total_score)
        
        # ç”Ÿæˆåˆ†ææ‘˜è¦
        summary = self._generate_summary(code, total_score, rating, {
            'financial_health': financial_health,
            'profitability': profitability,
            'growth': growth,
            'valuation': valuation,
            'technical': technical
        })
        
        return AnalysisResult(
            code=code,
            analysis_type='comprehensive',
            score=total_score,
            rating=rating,
            summary=summary,
            details={
                'financial_health': financial_health,
                'profitability': profitability,
                'growth': growth,
                'valuation': valuation,
                'technical': technical
            }
        )
```

## ğŸš€ å®‰è£…é…ç½®

### ç¯å¢ƒè¦æ±‚

- Python 3.8+
- å†…å­˜: 4GBä»¥ä¸Šæ¨è
- å­˜å‚¨: æ ¹æ®æ•°æ®é‡ï¼Œå»ºè®®é¢„ç•™10GBä»¥ä¸Šç©ºé—´
- ç½‘ç»œ: ç¨³å®šçš„äº’è”ç½‘è¿æ¥ï¼ˆç”¨äºæ•°æ®è·å–ï¼‰

### å®‰è£…æ­¥éª¤

1. **å…‹éš†é¡¹ç›®**
```bash
git clone https://github.com/your-repo/stock_db.git
cd stock_db
```

2. **åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ**
```bash
python -m venv venv

# Windows
venv\Scripts\activate

# Linux/Mac
source venv/bin/activate
```

3. **å®‰è£…ä¾èµ–**
```bash
pip install -r requirements.txt
```

4. **é…ç½®æ–‡ä»¶**
```bash
cp config_example.yaml config.yaml
# ç¼–è¾‘config.yamlï¼Œå¡«å…¥æ•°æ®æºé…ç½®
```

### é…ç½®è¯´æ˜

```yaml
# config.yaml
database:
  type: "duckdb"
  path: "stock_data.db"
  
data_sources:
  jqdata:
    enabled: true
    username: "your_username"
    password: "your_password"
    
logging:
  level: "INFO"
  file: "stock_data.log"
  
update:
  auto_update: true
  update_time: "09:00"
  batch_size: 100
```

## ğŸ“– ä½¿ç”¨æŒ‡å—

### å‘½ä»¤è¡Œå·¥å…·

#### åˆå§‹åŒ–æ•°æ®åº“
```bash
python main.py init --db-path stock_data.db
```

#### æ›´æ–°è‚¡ç¥¨åˆ—è¡¨
```bash
python main.py update-stock-list
python main.py update-stock-list --force  # å¼ºåˆ¶æ›´æ–°
```

#### æ•°æ®æ›´æ–°
```bash
# å¢é‡æ›´æ–°
python main.py update

# æ¯æ—¥æ›´æ–°
python main.py daily

# æŒ‡å®šè‚¡ç¥¨æ›´æ–°
python main.py update --codes 000001.XSHE,000002.XSHE
```

#### æ•°æ®æŸ¥è¯¢
```bash
# æŸ¥çœ‹æ•°æ®åº“ä¿¡æ¯
python main.py info

# æ‰§è¡ŒSQLæŸ¥è¯¢
python main.py query "SELECT * FROM stock_list LIMIT 10"
```

#### è‚¡ç¥¨åˆ†æ
```bash
# ç»¼åˆåˆ†æ
python main.py analyze 000001.XSHE

# æŒ‡å®šåˆ†æç±»å‹
python main.py analyze 000001.XSHE --type financial_health
```

#### è‚¡ç¥¨ç­›é€‰
```bash
# æŒ‰æ¡ä»¶ç­›é€‰
python main.py screen --pe-min 5 --pe-max 20 --pb-max 3
```

#### æ•°æ®è´¨é‡æ£€æŸ¥
```bash
python main.py check-quality
```

### Python API

#### åŸºç¡€ä½¿ç”¨

```python
from stock_db import QuantDataAPI, create_api

# æ–¹å¼1: ç›´æ¥åˆ›å»º
api = QuantDataAPI("stock_data.db")

# æ–¹å¼2: é€šè¿‡å·¥å‚å‡½æ•°åˆ›å»º
api = create_api(
    db_path="stock_data.db",
    jq_username="your_username",
    jq_password="your_password"
)

# è·å–è‚¡ç¥¨åˆ—è¡¨
stock_list = api.get_stock_list()
print(f"è‚¡ç¥¨æ€»æ•°: {len(stock_list)}")

# è·å–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯
basic_info = api.get_stock_basic_info("000001.XSHE")
print(f"è‚¡ç¥¨åç§°: {basic_info['display_name']}")

# å…³é—­è¿æ¥
api.close()
```

#### æ•°æ®è·å–

```python
# è·å–ä»·æ ¼æ•°æ®
price_data = api.get_price_data(
    code="000001.XSHE",
    start_date=date(2023, 1, 1),
    end_date=date(2023, 12, 31)
)

# è·å–è´¢åŠ¡æ•°æ®
financial_data = api.get_financial_data(
    code="000001.XSHE",
    data_type="income_statement",
    count=8  # æœ€è¿‘8ä¸ªå­£åº¦
)

# è·å–ä¼°å€¼æ•°æ®
valuation_data = api.get_valuation_data(
    code="000001.XSHE",
    start_date=date(2023, 1, 1),
    end_date=date(2023, 12, 31)
)
```

#### å¿«é€ŸæŸ¥è¯¢å‡½æ•°

```python
from stock_db import quick_query, analyze_stock

# å¿«é€ŸæŸ¥è¯¢ä»·æ ¼æ•°æ®ï¼ˆæœ€è¿‘30å¤©ï¼‰
price_data = quick_query("000001.XSHE", "price", 30)

# å¿«é€ŸæŸ¥è¯¢ä¼°å€¼æ•°æ®
valuation_data = quick_query("000001.XSHE", "valuation", 30)

# å¿«é€Ÿåˆ†æ
result = analyze_stock("000001.XSHE", "comprehensive")
print(f"è¯„åˆ†: {result.score}, è¯„çº§: {result.rating}")
```

#### æ‰¹é‡æ“ä½œ

```python
# æ‰¹é‡è·å–æ•°æ®
codes = ["000001.XSHE", "000002.XSHE", "600000.XSHG"]
batch_data = api.get_batch_data(codes, "price", start_date, end_date)

# æ‰¹é‡åˆ†æ
batch_results = api.batch_analysis(codes, "comprehensive")

# è‚¡ç¥¨æ’å
rankings = api.rank_stocks(codes, "comprehensive")
for i, stock in enumerate(rankings, 1):
    print(f"{i}. {stock['code']}: {stock['score']}")
```

## ğŸ“Š æ•°æ®æ¨¡å‹

### æ•°æ®åº“è¡¨ç»“æ„

#### è‚¡ç¥¨åˆ—è¡¨è¡¨ (`stock_list`)

| å­—æ®µå | ç±»å‹ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|------|------|------|
| code | VARCHAR | è‚¡ç¥¨ä»£ç  | 000001.XSHE |
| display_name | VARCHAR | æ˜¾ç¤ºåç§° | å¹³å®‰é“¶è¡Œ |
| name | VARCHAR | è‚¡ç¥¨åç§° | å¹³å®‰é“¶è¡Œè‚¡ä»½æœ‰é™å…¬å¸ |
| start_date | DATE | ä¸Šå¸‚æ—¥æœŸ | 1991-04-03 |
| end_date | DATE | é€€å¸‚æ—¥æœŸ | NULL |
| exchange | VARCHAR | äº¤æ˜“æ‰€ | XSHE |
| market | VARCHAR | å¸‚åœºæ¿å— | main |
| industry_name | VARCHAR | è¡Œä¸šåç§° | é“¶è¡Œ |
| status | VARCHAR | çŠ¶æ€ | normal |

#### ä»·æ ¼æ•°æ®è¡¨ (`price_data`)

| å­—æ®µå | ç±»å‹ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|------|------|------|
| code | VARCHAR | è‚¡ç¥¨ä»£ç  | 000001.XSHE |
| date | DATE | äº¤æ˜“æ—¥æœŸ | 2023-12-29 |
| open | DECIMAL | å¼€ç›˜ä»· | 10.50 |
| high | DECIMAL | æœ€é«˜ä»· | 10.80 |
| low | DECIMAL | æœ€ä½ä»· | 10.45 |
| close | DECIMAL | æ”¶ç›˜ä»· | 10.75 |
| volume | BIGINT | æˆäº¤é‡ | 12345678 |
| amount | DECIMAL | æˆäº¤é¢ | 132456789.50 |

#### è´¢åŠ¡æ•°æ®è¡¨ (`income_statement`)

| å­—æ®µå | ç±»å‹ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|------|------|------|
| code | VARCHAR | è‚¡ç¥¨ä»£ç  | 000001.XSHE |
| pub_date | DATE | å…¬å¸ƒæ—¥æœŸ | 2023-04-28 |
| stat_date | DATE | ç»Ÿè®¡æ—¥æœŸ | 2023-03-31 |
| total_operating_revenue | DECIMAL | è¥ä¸šæ€»æ”¶å…¥ | 45678901234.56 |
| operating_profit | DECIMAL | è¥ä¸šåˆ©æ¶¦ | 12345678901.23 |
| net_profit | DECIMAL | å‡€åˆ©æ¶¦ | 9876543210.98 |

### æ•°æ®å…³ç³»å›¾

```
stock_list (è‚¡ç¥¨åˆ—è¡¨)
    â”œâ”€â”€ price_data (ä»·æ ¼æ•°æ®)
    â”œâ”€â”€ fundamental_data (åŸºæœ¬é¢æ•°æ®)
    â”œâ”€â”€ income_statement (åˆ©æ¶¦è¡¨)
    â”œâ”€â”€ balance_sheet (èµ„äº§è´Ÿå€ºè¡¨)
    â”œâ”€â”€ cash_flow_statement (ç°é‡‘æµé‡è¡¨)
    â””â”€â”€ indicator_data (æŠ€æœ¯æŒ‡æ ‡)
```

## ğŸ”Œ APIæ¥å£

### æ ¸å¿ƒAPIç±»

#### QuantDataAPI

```python
class QuantDataAPI:
    """é‡åŒ–æ•°æ®APIä¸»ç±»"""
    
    def __init__(self, db_path: str, config_path: str = None):
        """åˆå§‹åŒ–API"""
        pass
    
    # è‚¡ç¥¨åŸºç¡€ä¿¡æ¯
    def get_stock_list(self, market: str = None) -> pd.DataFrame:
        """è·å–è‚¡ç¥¨åˆ—è¡¨"""
        pass
    
    def get_stock_basic_info(self, code: str) -> dict:
        """è·å–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯"""
        pass
    
    # ä»·æ ¼æ•°æ®
    def get_price_data(self, code: str, start_date: date, end_date: date) -> pd.DataFrame:
        """è·å–ä»·æ ¼æ•°æ®"""
        pass
    
    def get_latest_price(self, code: str) -> dict:
        """è·å–æœ€æ–°ä»·æ ¼"""
        pass
    
    # è´¢åŠ¡æ•°æ®
    def get_financial_data(self, code: str, data_type: str, count: int = 8) -> pd.DataFrame:
        """è·å–è´¢åŠ¡æ•°æ®"""
        pass
    
    def get_income_statement(self, code: str, count: int = 8) -> pd.DataFrame:
        """è·å–åˆ©æ¶¦è¡¨"""
        pass
    
    def get_balance_sheet(self, code: str, count: int = 8) -> pd.DataFrame:
        """è·å–èµ„äº§è´Ÿå€ºè¡¨"""
        pass
    
    def get_cash_flow_statement(self, code: str, count: int = 8) -> pd.DataFrame:
        """è·å–ç°é‡‘æµé‡è¡¨"""
        pass
    
    # ä¼°å€¼æ•°æ®
    def get_valuation_data(self, code: str, start_date: date, end_date: date) -> pd.DataFrame:
        """è·å–ä¼°å€¼æ•°æ®"""
        pass
    
    # æŠ€æœ¯æŒ‡æ ‡
    def get_technical_indicators(self, code: str, indicators: list, period: int = 30) -> pd.DataFrame:
        """è·å–æŠ€æœ¯æŒ‡æ ‡"""
        pass
    
    # æ•°æ®åˆ†æ
    def analyze_financial_health(self, code: str) -> AnalysisResult:
        """è´¢åŠ¡å¥åº·åˆ†æ"""
        pass
    
    def analyze_profitability(self, code: str) -> AnalysisResult:
        """ç›ˆåˆ©èƒ½åŠ›åˆ†æ"""
        pass
    
    def analyze_growth(self, code: str) -> AnalysisResult:
        """æˆé•¿æ€§åˆ†æ"""
        pass
    
    def analyze_valuation(self, code: str) -> AnalysisResult:
        """ä¼°å€¼åˆ†æ"""
        pass
    
    def comprehensive_analysis(self, code: str) -> AnalysisResult:
        """ç»¼åˆåˆ†æ"""
        pass
    
    # è‚¡ç¥¨ç­›é€‰
    def screen_stocks(self, criteria: dict) -> pd.DataFrame:
        """è‚¡ç¥¨ç­›é€‰"""
        pass
    
    # æ‰¹é‡æ“ä½œ
    def batch_analysis(self, codes: list, analysis_type: str) -> list:
        """æ‰¹é‡åˆ†æ"""
        pass
    
    def rank_stocks(self, codes: list, criteria: str) -> list:
        """è‚¡ç¥¨æ’å"""
        pass
    
    # æ•°æ®æ›´æ–°
    def update_stock_data(self, code: str, data_types: list = None) -> bool:
        """æ›´æ–°è‚¡ç¥¨æ•°æ®"""
        pass
    
    def daily_update(self) -> dict:
        """æ¯æ—¥æ›´æ–°"""
        pass
    
    # æ•°æ®è´¨é‡
    def check_data_quality(self) -> dict:
        """æ•°æ®è´¨é‡æ£€æŸ¥"""
        pass
    
    # æ•°æ®åº“ç®¡ç†
    def get_database_info(self) -> dict:
        """è·å–æ•°æ®åº“ä¿¡æ¯"""
        pass
    
    def query(self, sql: str, params: list = None) -> pd.DataFrame:
        """æ‰§è¡ŒSQLæŸ¥è¯¢"""
        pass
    
    def close(self):
        """å…³é—­è¿æ¥"""
        pass
```

### ä¾¿æ·å‡½æ•°

```python
# å¿«é€ŸæŸ¥è¯¢å‡½æ•°
def quick_query(code: str, data_type: str, period: int = 30) -> pd.DataFrame:
    """å¿«é€ŸæŸ¥è¯¢æ•°æ®"""
    pass

# å¿«é€Ÿåˆ†æå‡½æ•°
def analyze_stock(code: str, analysis_type: str = "comprehensive") -> AnalysisResult:
    """å¿«é€Ÿåˆ†æè‚¡ç¥¨"""
    pass

# å·¥å‚å‡½æ•°
def create_api(db_path: str, **kwargs) -> QuantDataAPI:
    """åˆ›å»ºAPIå®ä¾‹"""
    pass

# è·å–è‚¡ç¥¨æ•°æ®
def get_stock_data(code: str, data_type: str, **kwargs) -> pd.DataFrame:
    """è·å–è‚¡ç¥¨æ•°æ®"""
    pass
```

## ğŸ§ª æµ‹è¯•ä½“ç³»

### æµ‹è¯•æ¶æ„

```
test/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ test_system.py              # ç³»ç»Ÿé›†æˆæµ‹è¯•
â”œâ”€â”€ test_stock_list.py          # è‚¡ç¥¨åˆ—è¡¨åŠŸèƒ½æµ‹è¯•
â”œâ”€â”€ test_stock_list_simple.py   # æ ¸å¿ƒåŠŸèƒ½å•å…ƒæµ‹è¯•
â””â”€â”€ conftest.py                 # æµ‹è¯•é…ç½®
```

### æµ‹è¯•ç±»å‹

#### 1. å•å…ƒæµ‹è¯•

```python
# test/test_stock_list_simple.py
def test_stock_info_model():
    """æµ‹è¯•StockInfoæ¨¡å‹"""
    stock_info = StockInfo(
        code='000001.XSHE',
        display_name='å¹³å®‰é“¶è¡Œ',
        name='å¹³å®‰é“¶è¡Œ',
        start_date=date(1991, 4, 3)
    )
    
    assert stock_info.code == '000001.XSHE'
    assert stock_info.is_active == True
    assert stock_info.to_jq_code() == '000001.XSHE'
    assert stock_info.exchange_name == 'æ·±åœ³è¯åˆ¸äº¤æ˜“æ‰€'
```

#### 2. é›†æˆæµ‹è¯•

```python
# test/test_system.py
def test_api_functions():
    """æµ‹è¯•APIåŠŸèƒ½"""
    api = QuantDataAPI("test_stock_data.db")
    
    # æµ‹è¯•è‚¡ç¥¨åˆ—è¡¨è·å–
    stock_list = api.get_stock_list()
    assert isinstance(stock_list, pd.DataFrame)
    
    # æµ‹è¯•æ•°æ®åº“ä¿¡æ¯
    db_info = api.get_database_info()
    assert isinstance(db_info, dict)
    
    api.close()
```

#### 3. æ€§èƒ½æµ‹è¯•

```python
def test_query_performance():
    """æµ‹è¯•æŸ¥è¯¢æ€§èƒ½"""
    api = QuantDataAPI("stock_data.db")
    
    start_time = time.time()
    result = api.get_price_data("000001.XSHE", start_date, end_date)
    end_time = time.time()
    
    # æŸ¥è¯¢æ—¶é—´åº”å°äº1ç§’
    assert end_time - start_time < 1.0
    assert len(result) > 0
```

### è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
python run_tests.py

# è¿è¡Œå•ä¸ªæµ‹è¯•æ–‡ä»¶
python test/test_system.py
python test/test_stock_list_simple.py

# ä½¿ç”¨pytestè¿è¡Œ
pytest test/ -v

# ç”Ÿæˆæµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
pytest test/ --cov=. --cov-report=html
```

### æµ‹è¯•ç»“æœ

```
============================================================
æµ‹è¯•ç»“æœæ±‡æ€»
============================================================
test/test_system.py: âœ… é€šè¿‡ (7/7é¡¹)
test/test_stock_list_simple.py: âœ… é€šè¿‡ (4/4é¡¹)
test/test_stock_list.py: âš ï¸ éƒ¨åˆ†é€šè¿‡ (3/4é¡¹)

æ€»è®¡: 14/15 é¡¹æµ‹è¯•é€šè¿‡
ğŸ‰ æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼
```

## ğŸ“ˆ æ•°æ®äº§å‡º

### æ•°æ®è¦†ç›–èŒƒå›´

#### è‚¡ç¥¨åŸºç¡€æ•°æ®
- **è‚¡ç¥¨åˆ—è¡¨**: å…¨å¸‚åœº4000+åªè‚¡ç¥¨
- **åŸºæœ¬ä¿¡æ¯**: è‚¡ç¥¨ä»£ç ã€åç§°ã€ä¸Šå¸‚æ—¥æœŸã€è¡Œä¸šåˆ†ç±»
- **å¸‚åœºåˆ†ç±»**: ä¸»æ¿ã€åˆ›ä¸šæ¿ã€ç§‘åˆ›æ¿ã€åŒ—äº¤æ‰€
- **çŠ¶æ€ä¿¡æ¯**: æ­£å¸¸äº¤æ˜“ã€åœç‰Œã€é€€å¸‚ç­‰

#### ä»·æ ¼æ•°æ®
- **æ—¥çº¿æ•°æ®**: å¼€é«˜ä½æ”¶ã€æˆäº¤é‡ã€æˆäº¤é¢
- **å†å²æ•°æ®**: æ”¯æŒè·å–å®Œæ•´å†å²æ•°æ®
- **å®æ—¶æ•°æ®**: å½“æ—¥æœ€æ–°ä»·æ ¼ä¿¡æ¯
- **å¤æƒå¤„ç†**: å‰å¤æƒã€åå¤æƒä»·æ ¼

#### è´¢åŠ¡æ•°æ®
- **åˆ©æ¶¦è¡¨**: è¥ä¸šæ”¶å…¥ã€å‡€åˆ©æ¶¦ã€æ¯›åˆ©ç‡ç­‰
- **èµ„äº§è´Ÿå€ºè¡¨**: æ€»èµ„äº§ã€å‡€èµ„äº§ã€è´Ÿå€ºç‡ç­‰
- **ç°é‡‘æµé‡è¡¨**: ç»è¥ç°é‡‘æµã€æŠ•èµ„ç°é‡‘æµç­‰
- **è´¢åŠ¡æŒ‡æ ‡**: ROEã€ROAã€EPSã€BPSç­‰

#### ä¼°å€¼æ•°æ®
- **ä¼°å€¼æŒ‡æ ‡**: PEã€PBã€PSã€EV/EBITDA
- **å¸‚å€¼æ•°æ®**: æ€»å¸‚å€¼ã€æµé€šå¸‚å€¼
- **åˆ†çº¢æ•°æ®**: è‚¡æ¯ç‡ã€åˆ†çº¢æ¯”ä¾‹

#### æŠ€æœ¯æŒ‡æ ‡
- **è¶‹åŠ¿æŒ‡æ ‡**: MAã€EMAã€MACDã€å¸ƒæ—å¸¦
- **åŠ¨é‡æŒ‡æ ‡**: RSIã€KDJã€å¨å»‰æŒ‡æ ‡
- **æˆäº¤é‡æŒ‡æ ‡**: OBVã€æˆäº¤é‡æ¯”ç‡

### æ•°æ®è´¨é‡ä¿è¯

#### æ•°æ®éªŒè¯
```python
def validate_price_data(data: pd.DataFrame) -> dict:
    """ä»·æ ¼æ•°æ®éªŒè¯"""
    issues = []
    
    # æ£€æŸ¥å¿…è¦å­—æ®µ
    required_fields = ['code', 'date', 'open', 'high', 'low', 'close', 'volume']
    missing_fields = [f for f in required_fields if f not in data.columns]
    if missing_fields:
        issues.append(f"ç¼ºå°‘å­—æ®µ: {missing_fields}")
    
    # æ£€æŸ¥ä»·æ ¼é€»è¾‘
    invalid_prices = data[(data['high'] < data['low']) | 
                         (data['high'] < data['open']) | 
                         (data['high'] < data['close'])]
    if not invalid_prices.empty:
        issues.append(f"ä»·æ ¼é€»è¾‘é”™è¯¯: {len(invalid_prices)}æ¡è®°å½•")
    
    # æ£€æŸ¥æ•°æ®è¿ç»­æ€§
    date_gaps = data['date'].diff().dt.days
    large_gaps = date_gaps[date_gaps > 7]  # è¶…è¿‡7å¤©çš„é—´éš”
    if not large_gaps.empty:
        issues.append(f"æ•°æ®é—´éš”è¿‡å¤§: {len(large_gaps)}å¤„")
    
    return {
        'valid': len(issues) == 0,
        'issues': issues,
        'total_records': len(data)
    }
```

#### æ•°æ®ä¿®å¤
```python
def repair_price_data(data: pd.DataFrame) -> pd.DataFrame:
    """ä»·æ ¼æ•°æ®ä¿®å¤"""
    # ä¿®å¤å¼‚å¸¸ä»·æ ¼
    data.loc[data['high'] < data['low'], ['high', 'low']] = \
        data.loc[data['high'] < data['low'], ['low', 'high']].values
    
    # å¡«è¡¥ç¼ºå¤±æ•°æ®
    data['volume'] = data['volume'].fillna(0)
    data['amount'] = data['amount'].fillna(0)
    
    # ç§»é™¤é‡å¤æ•°æ®
    data = data.drop_duplicates(subset=['code', 'date'])
    
    return data
```

### æ•°æ®æ›´æ–°ç­–ç•¥

#### å¢é‡æ›´æ–°
```python
def incremental_update():
    """å¢é‡æ›´æ–°ç­–ç•¥"""
    # 1. æ£€æŸ¥æœ€åæ›´æ–°æ—¶é—´
    last_update = get_last_update_time()
    
    # 2. ç¡®å®šéœ€è¦æ›´æ–°çš„æ—¥æœŸèŒƒå›´
    start_date = last_update + timedelta(days=1)
    end_date = date.today()
    
    # 3. è·å–æ´»è·ƒè‚¡ç¥¨åˆ—è¡¨
    active_stocks = get_active_stocks()
    
    # 4. æ‰¹é‡æ›´æ–°æ•°æ®
    for batch in batch_split(active_stocks, batch_size=100):
        update_batch_data(batch, start_date, end_date)
    
    # 5. æ›´æ–°æ—¶é—´æˆ³
    update_last_update_time(end_date)
```

#### å®šæœŸå…¨é‡æ›´æ–°
```python
def full_update_schedule():
    """å®šæœŸå…¨é‡æ›´æ–°"""
    # æ¯å‘¨æœ«è¿›è¡Œå…¨é‡æ•°æ®æ£€æŸ¥å’Œä¿®å¤
    if datetime.now().weekday() == 6:  # å‘¨æ—¥
        # 1. æ•°æ®è´¨é‡æ£€æŸ¥
        quality_report = check_data_quality()
        
        # 2. ä¿®å¤å‘ç°çš„é—®é¢˜
        if quality_report['issues']:
            repair_data_issues(quality_report['issues'])
        
        # 3. é‡æ–°è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        recalculate_technical_indicators()
        
        # 4. æ›´æ–°è‚¡ç¥¨åˆ—è¡¨
        update_stock_list(force=True)
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### æŸ¥è¯¢ä¼˜åŒ–

#### ç´¢å¼•ç­–ç•¥
```sql
-- ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•
CREATE INDEX idx_price_code_date ON price_data(code, date);
CREATE INDEX idx_financial_code_date ON income_statement(code, stat_date);
CREATE INDEX idx_stock_list_market ON stock_list(market, status);
```

#### æŸ¥è¯¢ä¼˜åŒ–
```python
def optimized_query(self, code: str, start_date: date, end_date: date) -> pd.DataFrame:
    """ä¼˜åŒ–çš„æŸ¥è¯¢æ–¹æ³•"""
    # ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢ï¼Œé¿å…SQLæ³¨å…¥
    sql = """
    SELECT code, date, open, high, low, close, volume, amount
    FROM price_data 
    WHERE code = ? AND date BETWEEN ? AND ?
    ORDER BY date
    """
    
    # ä½¿ç”¨DuckDBçš„å‘é‡åŒ–æŸ¥è¯¢
    return self.db_manager.query(sql, [code, start_date, end_date])
```

### ç¼“å­˜æœºåˆ¶

```python
from functools import lru_cache
from datetime import datetime, timedelta

class CachedDataService:
    """å¸¦ç¼“å­˜çš„æ•°æ®æœåŠ¡"""
    
    def __init__(self):
        self.cache = {}
        self.cache_ttl = timedelta(minutes=30)
    
    @lru_cache(maxsize=1000)
    def get_stock_basic_info(self, code: str) -> dict:
        """ç¼“å­˜è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯"""
        return self._fetch_stock_basic_info(code)
    
    def get_price_data_cached(self, code: str, start_date: date, end_date: date) -> pd.DataFrame:
        """å¸¦ç¼“å­˜çš„ä»·æ ¼æ•°æ®è·å–"""
        cache_key = f"{code}_{start_date}_{end_date}"
        
        # æ£€æŸ¥ç¼“å­˜
        if cache_key in self.cache:
            cached_data, cached_time = self.cache[cache_key]
            if datetime.now() - cached_time < self.cache_ttl:
                return cached_data
        
        # è·å–æ–°æ•°æ®
        data = self._fetch_price_data(code, start_date, end_date)
        
        # æ›´æ–°ç¼“å­˜
        self.cache[cache_key] = (data, datetime.now())
        
        return data
```

### æ‰¹é‡å¤„ç†

```python
def batch_update_stocks(self, codes: list, data_type: str) -> dict:
    """æ‰¹é‡æ›´æ–°è‚¡ç¥¨æ•°æ®"""
    results = {'success': [], 'failed': []}
    
    # åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å†…å­˜æº¢å‡º
    batch_size = 50
    for i in range(0, len(codes), batch_size):
        batch_codes = codes[i:i + batch_size]
        
        try:
            # æ‰¹é‡è·å–æ•°æ®
            batch_data = self.data_source.get_batch_data(batch_codes, data_type)
            
            # æ‰¹é‡æ’å…¥æ•°æ®åº“
            self.db_manager.batch_insert(data_type, batch_data)
            
            results['success'].extend(batch_codes)
            
        except Exception as e:
            logger.error(f"æ‰¹é‡æ›´æ–°å¤±è´¥: {e}")
            results['failed'].extend(batch_codes)
    
    return results
```

## ğŸ”§ æ‰©å±•å¼€å‘

### æ·»åŠ æ–°æ•°æ®æº

#### 1. å®ç°æ•°æ®æºæ¥å£

```python
class WindDataSource(BaseDataSource):
    """Windæ•°æ®æºå®ç°"""
    
    def __init__(self, config: DataSourceConfig):
        self.config = config
        self.authenticated = False
    
    def authenticate(self) -> bool:
        """Windè®¤è¯"""
        try:
            from WindPy import w
            w.start()
            self.authenticated = True
            return True
        except Exception as e:
            logger.error(f"Windè®¤è¯å¤±è´¥: {e}")
            return False
    
    def get_stock_list(self) -> pd.DataFrame:
        """è·å–è‚¡ç¥¨åˆ—è¡¨"""
        from WindPy import w
        
        # è·å–Aè‚¡åˆ—è¡¨
        data = w.wset("sectorconstituent", "date=20231229;sectorid=a001010100000000")
        
        # è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
        stocks = []
        for code in data.Data[1]:
            stock_info = StockInfo(
                code=self._to_standard_code(code),
                display_name=self._get_stock_name(code),
                name=self._get_stock_name(code)
            )
            stocks.append(stock_info.to_dict())
        
        return pd.DataFrame(stocks)
    
    def get_price_data(self, code: str, start_date: date, end_date: date) -> pd.DataFrame:
        """è·å–ä»·æ ¼æ•°æ®"""
        from WindPy import w
        
        wind_code = self._to_wind_code(code)
        data = w.wsd(wind_code, "open,high,low,close,volume,amt", 
                    start_date, end_date, "")
        
        # è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
        df = pd.DataFrame(data.Data, 
                         columns=['open', 'high', 'low', 'close', 'volume', 'amount'],
                         index=data.Times)
        df['code'] = code
        df['date'] = df.index
        
        return df.reset_index(drop=True)
```

#### 2. æ³¨å†Œæ•°æ®æº

```python
# åœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ 
data_sources:
  wind:
    enabled: true
    username: "your_username"
    password: "your_password"

# åœ¨ä»£ç ä¸­æ³¨å†Œ
wind_config = DataSourceConfig(
    name="wind",
    source_type="wind",
    username=config.wind.username,
    password=config.wind.password
)
wind_source = WindDataSource(wind_config)
api.data_source_manager.add_source("wind", wind_source)
```

### æ·»åŠ æ–°åˆ†ææ¨¡å—

```python
class TechnicalAnalysisModule:
    """æŠ€æœ¯åˆ†ææ¨¡å—"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    def calculate_macd(self, code: str, period: int = 250) -> pd.DataFrame:
        """è®¡ç®—MACDæŒ‡æ ‡"""
        # è·å–ä»·æ ¼æ•°æ®
        price_data = self.db_manager.query(
            "SELECT date, close FROM price_data WHERE code = ? ORDER BY date DESC LIMIT ?",
            [code, period]
        )
        
        # è®¡ç®—MACD
        exp1 = price_data['close'].ewm(span=12).mean()
        exp2 = price_data['close'].ewm(span=26).mean()
        macd = exp1 - exp2
        signal = macd.ewm(span=9).mean()
        histogram = macd - signal
        
        return pd.DataFrame({
            'date': price_data['date'],
            'macd': macd,
            'signal': signal,
            'histogram': histogram
        })
    
    def analyze_trend(self, code: str) -> AnalysisResult:
        """è¶‹åŠ¿åˆ†æ"""
        # è·å–æŠ€æœ¯æŒ‡æ ‡
        macd_data = self.calculate_macd(code)
        ma_data = self.calculate_moving_averages(code)
        
        # åˆ†æè¶‹åŠ¿
        latest_macd = macd_data.iloc[-1]
        latest_ma = ma_data.iloc[-1]
        
        score = 50  # åŸºç¡€åˆ†æ•°
        
        # MACDä¿¡å·
        if latest_macd['macd'] > latest_macd['signal']:
            score += 20
        
        # å‡çº¿æ’åˆ—
        if latest_ma['ma5'] > latest_ma['ma20'] > latest_ma['ma60']:
            score += 20
        
        # ä»·æ ¼ä½ç½®
        if latest_ma['close'] > latest_ma['ma20']:
            score += 10
        
        return AnalysisResult(
            code=code,
            analysis_type='technical_trend',
            score=min(score, 100),
            rating=self._get_rating(score),
            summary=f"æŠ€æœ¯è¶‹åŠ¿åˆ†æè¯„åˆ†: {score}"
        )
```

### è‡ªå®šä¹‰æŒ‡æ ‡è®¡ç®—

```python
class CustomIndicators:
    """è‡ªå®šä¹‰æŒ‡æ ‡"""
    
    @staticmethod
    def calculate_rsi(prices: pd.Series, period: int = 14) -> pd.Series:
        """è®¡ç®—RSIæŒ‡æ ‡"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    @staticmethod
    def calculate_bollinger_bands(prices: pd.Series, period: int = 20, std_dev: int = 2) -> pd.DataFrame:
        """è®¡ç®—å¸ƒæ—å¸¦"""
        ma = prices.rolling(window=period).mean()
        std = prices.rolling(window=period).std()
        
        upper_band = ma + (std * std_dev)
        lower_band = ma - (std * std_dev)
        
        return pd.DataFrame({
            'middle': ma,
            'upper': upper_band,
            'lower': lower_band
        })
    
    @staticmethod
    def calculate_kdj(high: pd.Series, low: pd.Series, close: pd.Series, 
                     period: int = 9, m1: int = 3, m2: int = 3) -> pd.DataFrame:
        """è®¡ç®—KDJæŒ‡æ ‡"""
        lowest_low = low.rolling(window=period).min()
        highest_high = high.rolling(window=period).max()
        
        rsv = (close - lowest_low) / (highest_high - lowest_low) * 100
        
        k = rsv.ewm(alpha=1/m1).mean()
        d = k.ewm(alpha=1/m2).mean()
        j = 3 * k - 2 * d
        
        return pd.DataFrame({
            'k': k,
            'd': d,
            'j': j
        })
```

## ğŸš€ éƒ¨ç½²è¿ç»´

### ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

#### 1. ç¯å¢ƒå‡†å¤‡

```bash
# åˆ›å»ºç”Ÿäº§ç¯å¢ƒ
python -m venv prod_env
source prod_env/bin/activate

# å®‰è£…ä¾èµ–
pip install -r requirements.txt

# åˆ›å»ºæ•°æ®ç›®å½•
mkdir -p /data/stock_db
mkdir -p /logs/stock_db
```

#### 2. é…ç½®æ–‡ä»¶

```yaml
# config_prod.yaml
database:
  type: "duckdb"
  path: "/data/stock_db/stock_data.db"
  
data_sources:
  jqdata:
    enabled: true
    username: "${JQ_USERNAME}"
    password: "${JQ_PASSWORD}"
    
logging:
  level: "INFO"
  file: "/logs/stock_db/stock_data.log"
  max_size: "100MB"
  backup_count: 10
  
update:
  auto_update: true
  update_time: "09:00"
  batch_size: 100
  retry_times: 3
  
performance:
  cache_size: 1000
  query_timeout: 30
  batch_size: 100
```

#### 3. ç³»ç»ŸæœåŠ¡

```ini
# /etc/systemd/system/stock-data-updater.service
[Unit]
Description=Stock Data Updater Service
After=network.target

[Service]
Type=simple
User=stockdata
WorkingDirectory=/opt/stock_db
Environment=PYTHONPATH=/opt/stock_db
ExecStart=/opt/stock_db/prod_env/bin/python daily_update.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

#### 4. å®šæ—¶ä»»åŠ¡

```bash
# crontab -e
# æ¯æ—¥9ç‚¹æ›´æ–°æ•°æ®
0 9 * * 1-5 /opt/stock_db/prod_env/bin/python /opt/stock_db/main.py daily

# æ¯å‘¨æ—¥è¿›è¡Œæ•°æ®è´¨é‡æ£€æŸ¥
0 2 * * 0 /opt/stock_db/prod_env/bin/python /opt/stock_db/main.py check-quality

# æ¯æœˆ1å·æ›´æ–°è‚¡ç¥¨åˆ—è¡¨
0 1 1 * * /opt/stock_db/prod_env/bin/python /opt/stock_db/main.py update-stock-list --force
```

### ç›‘æ§å‘Šè­¦

#### 1. å¥åº·æ£€æŸ¥

```python
class HealthChecker:
    """å¥åº·æ£€æŸ¥"""
    
    def __init__(self, api: QuantDataAPI):
        self.api = api
    
    def check_database_health(self) -> dict:
        """æ•°æ®åº“å¥åº·æ£€æŸ¥"""
        try:
            # æ£€æŸ¥æ•°æ®åº“è¿æ¥
            db_info = self.api.get_database_info()
            
            # æ£€æŸ¥è¡¨ç»“æ„
            tables = self.api.query("SHOW TABLES")
            
            # æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
            stock_count = self.api.query("SELECT COUNT(*) as count FROM stock_list").iloc[0]['count']
            
            return {
                'status': 'healthy',
                'database_size': db_info.get('size', 0),
                'table_count': len(tables),
                'stock_count': stock_count,
                'last_check': datetime.now()
            }
        except Exception as e:
            return {
                'status': 'unhealthy',
                'error': str(e),
                'last_check': datetime.now()
            }
    
    def check_data_freshness(self) -> dict:
        """æ•°æ®æ–°é²œåº¦æ£€æŸ¥"""
        try:
            # æ£€æŸ¥æœ€æ–°æ•°æ®æ—¥æœŸ
            latest_date = self.api.query(
                "SELECT MAX(date) as latest_date FROM price_data"
            ).iloc[0]['latest_date']
            
            days_old = (date.today() - latest_date).days
            
            return {
                'latest_date': latest_date,
                'days_old': days_old,
                'is_fresh': days_old <= 3  # 3å¤©å†…ä¸ºæ–°é²œ
            }
        except Exception as e:
            return {
                'error': str(e),
                'is_fresh': False
            }
```

#### 2. å‘Šè­¦ç³»ç»Ÿ

```python
class AlertSystem:
    """å‘Šè­¦ç³»ç»Ÿ"""
    
    def __init__(self, config: dict):
        self.config = config
        self.email_config = config.get('email', {})
        self.webhook_config = config.get('webhook', {})
    
    def send_alert(self, level: str, title: str, message: str):
        """å‘é€å‘Šè­¦"""
        alert_data = {
            'level': level,
            'title': title,
            'message': message,
            'timestamp': datetime.now().isoformat(),
            'hostname': socket.gethostname()
        }
        
        # å‘é€é‚®ä»¶å‘Šè­¦
        if self.email_config.get('enabled'):
            self._send_email_alert(alert_data)
        
        # å‘é€Webhookå‘Šè­¦
        if self.webhook_config.get('enabled'):
            self._send_webhook_alert(alert_data)
    
    def _send_email_alert(self, alert_data: dict):
        """å‘é€é‚®ä»¶å‘Šè­¦"""
        import smtplib
        from email.mime.text import MIMEText
        
        msg = MIMEText(alert_data['message'])
        msg['Subject'] = f"[{alert_data['level'].upper()}] {alert_data['title']}"
        msg['From'] = self.email_config['from']
        msg['To'] = self.email_config['to']
        
        with smtplib.SMTP(self.email_config['smtp_server']) as server:
            server.login(self.email_config['username'], self.email_config['password'])
            server.send_message(msg)
    
    def _send_webhook_alert(self, alert_data: dict):
        """å‘é€Webhookå‘Šè­¦"""
        import requests
        
        requests.post(
            self.webhook_config['url'],
            json=alert_data,
            timeout=10
        )
```

#### 3. æ€§èƒ½ç›‘æ§

```python
class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§"""
    
    def __init__(self):
        self.metrics = {}
    
    def record_query_time(self, query_type: str, execution_time: float):
        """è®°å½•æŸ¥è¯¢æ—¶é—´"""
        if query_type not in self.metrics:
            self.metrics[query_type] = []
        
        self.metrics[query_type].append({
            'execution_time': execution_time,
            'timestamp': datetime.now()
        })
        
        # ä¿ç•™æœ€è¿‘1000æ¡è®°å½•
        if len(self.metrics[query_type]) > 1000:
            self.metrics[query_type] = self.metrics[query_type][-1000:]
    
    def get_performance_stats(self, query_type: str = None) -> dict:
        """è·å–æ€§èƒ½ç»Ÿè®¡"""
        if query_type:
            data = self.metrics.get(query_type, [])
            if not data:
                return {}
            
            times = [item['execution_time'] for item in data]
            return {
                'query_type': query_type,
                'count': len(times),
                'avg_time': sum(times) / len(times),
                'min_time': min(times),
                'max_time': max(times),
                'p95_time': sorted(times)[int(len(times) * 0.95)]
            }
        else:
            return {
                query_type: self.get_performance_stats(query_type)
                for query_type in self.metrics.keys()
            }
```

### æ—¥å¿—ç®¡ç†

#### æ—¥å¿—é…ç½®

```python
import logging
from logging.handlers import RotatingFileHandler

def setup_logging(config: dict):
    """è®¾ç½®æ—¥å¿—é…ç½®"""
    # åˆ›å»ºlogger
    logger = logging.getLogger('stock_db')
    logger.setLevel(getattr(logging, config.get('level', 'INFO')))
    
    # æ–‡ä»¶å¤„ç†å™¨
    file_handler = RotatingFileHandler(
        config.get('file', 'stock_db.log'),
        maxBytes=config.get('max_size', 100 * 1024 * 1024),  # 100MB
        backupCount=config.get('backup_count', 10)
    )
    
    # æ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler()
    
    # æ ¼å¼åŒ–å™¨
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger
```

### å¤‡ä»½æ¢å¤

#### æ•°æ®å¤‡ä»½

```bash
#!/bin/bash
# backup.sh

BACKUP_DIR="/backup/stock_db"
DATE=$(date +%Y%m%d_%H%M%S)
DB_PATH="/data/stock_db/stock_data.db"

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p $BACKUP_DIR

# å¤‡ä»½æ•°æ®åº“æ–‡ä»¶
cp $DB_PATH $BACKUP_DIR/stock_data_$DATE.db

# å‹ç¼©å¤‡ä»½æ–‡ä»¶
gzip $BACKUP_DIR/stock_data_$DATE.db

# åˆ é™¤7å¤©å‰çš„å¤‡ä»½
find $BACKUP_DIR -name "*.gz" -mtime +7 -delete

echo "å¤‡ä»½å®Œæˆ: stock_data_$DATE.db.gz"
```

#### æ•°æ®æ¢å¤

```bash
#!/bin/bash
# restore.sh

if [ $# -ne 1 ]; then
    echo "ç”¨æ³•: $0 <å¤‡ä»½æ–‡ä»¶>"
    exit 1
fi

BACKUP_FILE=$1
DB_PATH="/data/stock_db/stock_data.db"

# åœæ­¢æœåŠ¡
sudo systemctl stop stock-data-updater

# å¤‡ä»½å½“å‰æ•°æ®åº“
cp $DB_PATH $DB_PATH.backup.$(date +%Y%m%d_%H%M%S)

# æ¢å¤æ•°æ®åº“
if [[ $BACKUP_FILE == *.gz ]]; then
    gunzip -c $BACKUP_FILE > $DB_PATH
else
    cp $BACKUP_FILE $DB_PATH
fi

# å¯åŠ¨æœåŠ¡
sudo systemctl start stock-data-updater

echo "æ•°æ®æ¢å¤å®Œæˆ"
```

## ğŸ“š å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•å¤„ç†æ•°æ®æºè®¤è¯å¤±è´¥ï¼Ÿ

**A**: æ£€æŸ¥é…ç½®æ–‡ä»¶ä¸­çš„ç”¨æˆ·åå’Œå¯†ç æ˜¯å¦æ­£ç¡®ï¼Œç¡®ä¿è´¦æˆ·æœ‰æ•ˆä¸”æœ‰è¶³å¤Ÿçš„APIè°ƒç”¨æ¬¡æ•°ã€‚

```python
# æ£€æŸ¥è®¤è¯çŠ¶æ€
api = QuantDataAPI("stock_data.db")
auth_status = api.data_source_manager.check_authentication()
print(f"è®¤è¯çŠ¶æ€: {auth_status}")
```

### Q2: æŸ¥è¯¢é€Ÿåº¦æ…¢æ€ä¹ˆåŠï¼Ÿ

**A**: 
1. æ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†åˆé€‚çš„ç´¢å¼•
2. ä¼˜åŒ–æŸ¥è¯¢æ¡ä»¶ï¼Œé¿å…å…¨è¡¨æ‰«æ
3. ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢ä»£æ›¿å•æ¡æŸ¥è¯¢
4. è€ƒè™‘å¢åŠ ç¼“å­˜

```python
# æŸ¥çœ‹æŸ¥è¯¢æ‰§è¡Œè®¡åˆ’
api.query("EXPLAIN SELECT * FROM price_data WHERE code = '000001.XSHE'")
```

### Q3: æ•°æ®æ›´æ–°å¤±è´¥æ€ä¹ˆå¤„ç†ï¼Ÿ

**A**:
1. æ£€æŸ¥ç½‘ç»œè¿æ¥
2. æŸ¥çœ‹é”™è¯¯æ—¥å¿—
3. æ£€æŸ¥æ•°æ®æºAPIçŠ¶æ€
4. å°è¯•æ‰‹åŠ¨æ›´æ–°å•åªè‚¡ç¥¨

```python
# æ‰‹åŠ¨æ›´æ–°å•åªè‚¡ç¥¨
api.update_stock_data("000001.XSHE", force=True)
```

### Q4: å¦‚ä½•æ‰©å±•æ”¯æŒæ–°çš„æ•°æ®ç±»å‹ï¼Ÿ

**A**:
1. åœ¨`models/`ç›®å½•ä¸‹åˆ›å»ºæ–°çš„æ•°æ®æ¨¡å‹
2. åœ¨æ•°æ®æºä¸­å®ç°è·å–æ–¹æ³•
3. åœ¨æ•°æ®åº“ä¸­åˆ›å»ºå¯¹åº”è¡¨ç»“æ„
4. æ›´æ–°APIæ¥å£

### Q5: å¦‚ä½•ä¼˜åŒ–å­˜å‚¨ç©ºé—´ï¼Ÿ

**A**:
1. å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
2. ä½¿ç”¨æ•°æ®å‹ç¼©
3. æŒ‰æ—¶é—´åˆ†åŒºå­˜å‚¨
4. åªä¿ç•™å¿…è¦çš„å­—æ®µ

```python
# æ¸…ç†è¿‡æœŸæ•°æ®
api.query("DELETE FROM price_data WHERE date < '2020-01-01'")
```

## ğŸ”® æœªæ¥è§„åˆ’

### çŸ­æœŸç›®æ ‡ (3ä¸ªæœˆ)
- [ ] æ”¯æŒæ›´å¤šæ•°æ®æºï¼ˆWindã€åŒèŠ±é¡ºç­‰ï¼‰
- [ ] å¢åŠ å®æ—¶æ•°æ®æ¨é€åŠŸèƒ½
- [ ] ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
- [ ] å®Œå–„ç›‘æ§å‘Šè­¦ç³»ç»Ÿ

### ä¸­æœŸç›®æ ‡ (6ä¸ªæœˆ)
- [ ] æ”¯æŒæœŸè´§ã€å€ºåˆ¸ç­‰å…¶ä»–é‡‘èäº§å“
- [ ] å¢åŠ æœºå™¨å­¦ä¹ é¢„æµ‹æ¨¡å—
- [ ] å¼€å‘Webç®¡ç†ç•Œé¢
- [ ] æ”¯æŒåˆ†å¸ƒå¼éƒ¨ç½²

### é•¿æœŸç›®æ ‡ (1å¹´)
- [ ] æ„å»ºå®Œæ•´çš„é‡åŒ–äº¤æ˜“å¹³å°
- [ ] æ”¯æŒç­–ç•¥å›æµ‹å’Œå®ç›˜äº¤æ˜“
- [ ] æä¾›SaaSæœåŠ¡
- [ ] å»ºç«‹å¼€å‘è€…ç”Ÿæ€

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ MIT è®¸å¯è¯ - æŸ¥çœ‹ [LICENSE](LICENSE) æ–‡ä»¶äº†è§£è¯¦æƒ…ã€‚

## ğŸ“ è”ç³»æ–¹å¼

- é¡¹ç›®ä¸»é¡µ: [GitHub Repository]
- é—®é¢˜åé¦ˆ: [GitHub Issues]
- é‚®ç®±: contact@stockdata.com

## ğŸ™ è‡´è°¢

æ„Ÿè°¢ä»¥ä¸‹é¡¹ç›®å’ŒæœåŠ¡:
- [DuckDB](https://duckdb.org/) - é«˜æ€§èƒ½åˆ†ææ•°æ®åº“
- [èšå®½](https://www.joinquant.com/) - æ•°æ®æºæ”¯æŒ
- [Pandas](https://pandas.pydata.org/) - æ•°æ®å¤„ç†
- [NumPy](https://numpy.org/) - æ•°å€¼è®¡ç®—

---

**é‡åŒ–æ•°æ®å¹³å°** - è®©æ•°æ®é©±åŠ¨æŠ•èµ„å†³ç­– ğŸš€